<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Image Fetcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .setup-section {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .setup-section.hidden {
            display: none;
        }

        .api-setup {
            margin-bottom: 20px;
        }

        .api-setup label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .api-setup input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .api-setup input:focus {
            outline: none;
            border-color: #667eea;
        }

        .instructions {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.6;
        }

        .instructions a {
            color: #667eea;
            font-weight: 600;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-panel {
            padding: 30px;
            background: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .progress-info {
            flex: 1;
        }

        .progress-bar-container {
            background: #e9ecef;
            height: 24px;
            border-radius: 12px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .current-game {
            padding: 30px;
            border-bottom: 2px solid #e9ecef;
        }

        .current-game h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .search-query {
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            display: inline-block;
            color: #666;
            font-style: italic;
        }

        .search-edit {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .search-edit input {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .search-edit input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-small {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-small:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .images-grid {
            padding: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .image-card {
            border: 3px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .image-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-color: #667eea;
        }

        .image-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }

        .image-card .info {
            padding: 10px;
            text-align: center;
            background: #f8f9fa;
            font-size: 12px;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 1.2em;
            color: #666;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            margin: 20px 30px;
            border-radius: 6px;
            border: 2px solid #fcc;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .stats {
            display: flex;
            gap: 30px;
            margin-bottom: 10px;
        }

        .stat {
            font-size: 14px;
            color: #666;
        }

        .stat strong {
            color: #333;
            font-size: 18px;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px 15px;
            margin: 10px 30px;
            border-radius: 6px;
            border: 2px solid #c3e6cb;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .training-info {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: white;
            padding: 20px;
            margin: 20px 30px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }
        
        .ai-mode-info {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px;
            margin: 20px 30px;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ® Game Image Fetcher</h1>
            <p>Automated image downloader for game-info.json</p>
        </div>

        <div class="setup-section" id="setupSection">
            <div class="api-setup">
                <label for="apiKey">Google API Key:</label>
                <input type="text" id="apiKey" placeholder="Enter your Google API key">
            </div>
            <div class="api-setup">
                <label for="searchEngineId">Custom Search Engine ID:</label>
                <input type="text" id="searchEngineId" placeholder="Enter your Search Engine ID">
            </div>
            <div class="instructions">
                <strong>Setup Instructions:</strong><br>
                1. Get API Key: <a href="https://console.cloud.google.com/apis/credentials" target="_blank">Google Cloud Console</a> â†’ Create API Key â†’ Enable "Custom Search API" and "Cloud Vision API"<br>
                2. Get Search Engine ID: <a href="https://programmablesearchengine.google.com/" target="_blank">Programmable Search Engine</a> â†’ Create â†’ Enable "Image Search" â†’ Get ID<br>
                3. Enable <a href="https://console.cloud.google.com/apis/library/vision.googleapis.com" target="_blank">Cloud Vision API</a> for automatic AI image selection<br>
                4. Enter both values above and click Start
            </div>
            <button class="btn" onclick="startApp()">Start Fetching Images</button>
        </div>

        <div class="control-panel" id="controlPanel" style="display: none;">
            <div class="progress-info">
                <div class="stats">
                    <div class="stat">
                        <strong id="currentIndex">0</strong> / <span id="totalGames">0</span> games
                    </div>
                    <div class="stat">
                        Downloaded: <strong id="downloadCount">0</strong>
                    </div>
                    <div class="stat" id="trainingStatus">
                        Training: <strong id="trainingCount">0/100</strong>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn" onclick="skipGame()">Skip Game</button>
                <button class="btn" onclick="resetProgress()">Reset Progress</button>
                <button class="btn" onclick="resetTraining()" id="resetTrainingBtn">Reset Training</button>
            </div>
        </div>

        <div id="successMessage"></div>
        <div id="errorMessage"></div>

        <div class="current-game" id="currentGameSection" style="display: none;">
            <h2 id="gameTitle"></h2>
            <div class="search-query">Searching: <span id="searchQuery"></span></div>
            <div class="search-edit">
                <input type="text" id="searchInput" placeholder="Edit search query...">
                <button class="btn-small" onclick="updateSearch()">Search</button>
            </div>
        </div>

        <div class="images-grid" id="imagesGrid"></div>
    </div>

    <script>
        let games = [];
        let currentIndex = 0;
        let apiKey = '';
        let searchEngineId = '';
        let visionApiKey = '';
        let imageCounter = 1;
        let currentSearchQuery = '';
        let cachedImages = []; // Cache images to avoid re-fetching on skip
        let autoMode = false; // Whether to use AI auto-selection
        let retryAttempt = 0; // Track search retry attempts
        const MIN_ACCEPTABLE_SCORE = 60; // Minimum score to accept an image
        const MAX_RETRY_ATTEMPTS = 2; // Max times to retry with different search
        
        // === TRAINING MODE VARIABLES ===
        const TRAINING_THRESHOLD = 100; // Number of manual selections needed for training
        let trainingData = []; // Store manual selection data
        let isTrainingMode = true; // Start in training mode
        let manualSelectionCount = 0; // Track manual selections
        let learnedPatterns = null; // Store learned patterns from training
        let skipTimer = null; // Auto-skip timer
        const AUTO_SKIP_DELAY = 15000; // 15 seconds

        // Load saved progress
        function loadProgress() {
            const saved = localStorage.getItem('imageFetcherProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                currentIndex = progress.currentIndex || 0;
                imageCounter = progress.imageCounter || 1;
                manualSelectionCount = progress.manualSelectionCount || 0;
            }
            
            // Load training data
            const savedTraining = localStorage.getItem('visionTrainingData');
            if (savedTraining) {
                trainingData = JSON.parse(savedTraining);
            }
            
            // Load learned patterns
            const savedPatterns = localStorage.getItem('learnedPatterns');
            if (savedPatterns) {
                learnedPatterns = JSON.parse(savedPatterns);
            }
            
            // Check if we've completed training
            if (manualSelectionCount >= TRAINING_THRESHOLD && learnedPatterns) {
                isTrainingMode = false;
                autoMode = true;
            }
        }

        // Save progress
        function saveProgress() {
            localStorage.setItem('imageFetcherProgress', JSON.stringify({
                currentIndex,
                imageCounter,
                manualSelectionCount
            }));
            
            // Save training data
            if (trainingData.length > 0) {
                localStorage.setItem('visionTrainingData', JSON.stringify(trainingData));
            }
            
            // Save learned patterns
            if (learnedPatterns) {
                localStorage.setItem('learnedPatterns', JSON.stringify(learnedPatterns));
            }
        }

        // Load game data
        async function loadGameData() {
            try {
                const response = await fetch('game-info.json');
                games = await response.json();
                document.getElementById('totalGames').textContent = games.length;
                return true;
            } catch (error) {
                showError('Failed to load game-info.json: ' + error.message);
                return false;
            }
        }

        // Start the app
        async function startApp() {
            apiKey = document.getElementById('apiKey').value.trim();
            searchEngineId = document.getElementById('searchEngineId').value.trim();

            if (!apiKey || !searchEngineId) {
                alert('Please enter both API Key and Search Engine ID');
                return;
            }

            // Use same API key for Vision API
            visionApiKey = apiKey;
            
            // Check training status
            if (manualSelectionCount < TRAINING_THRESHOLD) {
                isTrainingMode = true;
                autoMode = false;
                alert(`Training Mode: You'll manually select ${TRAINING_THRESHOLD - manualSelectionCount} more images to train the AI. Progress: ${manualSelectionCount}/${TRAINING_THRESHOLD}`);
            } else {
                isTrainingMode = false;
                autoMode = true;
                alert('Training Complete! AI will now automatically select images based on your preferences.');
            }

            // Save API credentials
            localStorage.setItem('googleApiKey', apiKey);
            localStorage.setItem('googleSearchEngineId', searchEngineId);

            // Hide setup, show control panel
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('controlPanel').style.display = 'flex';
            document.getElementById('currentGameSection').style.display = 'block';

            // Load data and progress
            const loaded = await loadGameData();
            if (loaded) {
                loadProgress();
                loadCurrentGame();
            }
        }

        // Load current game images
        async function loadCurrentGame() {
            if (currentIndex >= games.length) {
                showSuccess('ðŸŽ‰ All games completed!');
                return;
            }

            const game = games[currentIndex];
            currentSearchQuery = game.title;
            retryAttempt = 0; // Reset retry counter for new game
            
            // Clear any existing skip timer
            clearSkipTimer();

            // Update UI
            document.getElementById('gameTitle').textContent = `Game #${currentIndex + 1}: ${game.title}`;
            document.getElementById('searchQuery').textContent = currentSearchQuery;
            document.getElementById('searchInput').value = currentSearchQuery;
            document.getElementById('currentIndex').textContent = currentIndex + 1;
            document.getElementById('downloadCount').textContent = imageCounter - 1;
            updateProgressBar();
            updateTrainingUI();

            // Load images for current game
            loadImages();
            
            // Start auto-skip timer
            startSkipTimer();
        }
        
        // Update training UI
        function updateTrainingUI() {
            const trainingCount = document.getElementById('trainingCount');
            const trainingStatus = document.getElementById('trainingStatus');
            const resetTrainingBtn = document.getElementById('resetTrainingBtn');
            
            if (trainingCount) {
                trainingCount.textContent = `${manualSelectionCount}/${TRAINING_THRESHOLD}`;
            }
            
            if (trainingStatus) {
                if (isTrainingMode) {
                    trainingStatus.style.color = '#856404';
                    trainingStatus.innerHTML = `ðŸŽ“ Training: <strong>${manualSelectionCount}/${TRAINING_THRESHOLD}</strong>`;
                } else {
                    trainingStatus.style.color = '#155724';
                    trainingStatus.innerHTML = `âœ… AI Mode: <strong>Trained</strong>`;
                }
            }
            
            if (resetTrainingBtn) {
                resetTrainingBtn.style.display = learnedPatterns ? 'block' : 'none';
            }
        }

        // Analyze image with Google Cloud Vision API
        async function analyzeImage(imageUrl) {
            try {
                const visionUrl = `https://vision.googleapis.com/v1/images:annotate?key=${visionApiKey}`;
                const requestBody = {
                    requests: [{
                        image: { source: { imageUri: imageUrl } },
                        features: [
                            { type: 'LABEL_DETECTION', maxResults: 10 },
                            { type: 'TEXT_DETECTION', maxResults: 5 },
                            { type: 'SAFE_SEARCH_DETECTION' },
                            { type: 'IMAGE_PROPERTIES' }
                        ]
                    }]
                };

                const response = await fetch(visionUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) return null;
                const data = await response.json();
                return data.responses[0];
            } catch (error) {
                console.error('Vision API error:', error);
                return null;
            }
        }

        // Score image based on Vision API analysis
        function scoreImage(visionData, gameTitle) {
            if (!visionData) return 0;
            
            let score = 0; // Start at 0 - must earn points
            const gameTitleLower = gameTitle.toLowerCase();
            const gameWords = gameTitleLower.split(/\s+/).filter(w => w.length > 2);
            
            // Use learned patterns if available (AI mode)
            const useLearnedPatterns = !isTrainingMode && learnedPatterns;

            // === TEXT DETECTION (CRITICAL - 60 points max) ===
            let hasGameTitle = false;
            if (visionData.textAnnotations && visionData.textAnnotations.length > 0) {
                const detectedText = visionData.textAnnotations[0].description.toLowerCase();
                let matchCount = 0;
                
                // Check for game title words in detected text
                gameWords.forEach(word => {
                    if (word.length > 3 && detectedText.includes(word)) {
                        matchCount++;
                        score += 20; // 20 points per matching word
                    }
                });
                
                // Bonus for matching multiple words from title
                if (matchCount >= 2) {
                    score += 30;
                    hasGameTitle = true;
                } else if (matchCount === 1) {
                    score += 10;
                    hasGameTitle = true;
                }
                
                // Apply learned text preference
                if (useLearnedPatterns) {
                    // Bonus based on user's text preference
                    const textBonus = (learnedPatterns.textPreference / 100) * 15;
                    score += textBonus;
                    
                    // Check for common text elements from training
                    learnedPatterns.commonTextElements.forEach(element => {
                        if (detectedText.includes(element)) {
                            score += 10;
                        }
                    });
                }
                
                // Bonus for centered/prominent text (typical of thumbnails)
                if (visionData.textAnnotations.length >= 3 && visionData.textAnnotations.length <= 15) {
                    score += 15; // Sweet spot for thumbnails
                }
            } else {
                // NO TEXT = Probably not a thumbnail (unless user prefers images without text)
                if (useLearnedPatterns && learnedPatterns.textPreference < 30) {
                    // User often selects images without text
                    score += 10;
                } else {
                    score -= 60;
                }
            }

            // === LABEL DETECTION (40 points max) ===
            if (visionData.labelAnnotations) {
                const labels = visionData.labelAnnotations.map(l => l.description.toLowerCase());
                
                if (useLearnedPatterns) {
                    // Use learned label preferences
                    labels.forEach(label => {
                        if (learnedPatterns.labelWeights[label]) {
                            // Weight based on how often user selected images with this label
                            score += learnedPatterns.labelWeights[label] * 30;
                        }
                    });
                    
                    // Bonus for top learned labels
                    const topLearnedLabels = learnedPatterns.topLabels.slice(0, 10);
                    topLearnedLabels.forEach(topLabel => {
                        if (labels.some(l => l.includes(topLabel) || topLabel.includes(l))) {
                            score += 15;
                        }
                    });
                } else {
                    // Original scoring for training mode
                    // EXCELLENT: Clear thumbnail indicators
                    const excellentLabels = ['logo', 'brand', 'graphic design', 'font', 'advertising'];
                    excellentLabels.forEach(label => {
                        if (labels.some(l => l.includes(label))) score += 20;
                    });
                    
                    // GOOD: Thumbnail-style indicators
                    const goodLabels = ['text', 'banner', 'poster', 'graphics', 'illustration'];
                    goodLabels.forEach(label => {
                        if (labels.some(l => l.includes(label))) score += 10;
                    });

                    // TERRIBLE: Game UI/Screenshot indicators - instant disqualification
                    const terribleLabels = [
                        'screenshot', 'gameplay', 'screen', 'video game software',
                        'user interface', 'display device', 'computer monitor',
                        'gaming', 'pc game', 'action game', 'strategy game',
                        'menu', 'hud', 'controller', 'joystick', 'console'
                    ];
                    terribleLabels.forEach(label => {
                        if (labels.some(l => l.includes(label))) score -= 50; // Heavy penalty
                    });
                    
                    // BAD: Website/generic content (not game thumbnails)
                    const badLabels = ['website', 'web page', 'webpage', 'internet', 'browser'];
                    badLabels.forEach(label => {
                        if (labels.some(l => l.includes(label))) score -= 20;
                    });
                }
            }

            // === IMAGE PROPERTIES (20 points max) ===
            if (visionData.imagePropertiesAnnotation) {
                const colors = visionData.imagePropertiesAnnotation.dominantColors?.colors || [];
                
                if (useLearnedPatterns) {
                    // Apply learned color preference
                    const colorCount = colors.length;
                    if (learnedPatterns.colorPreference === 'low' && colorCount <= 4) {
                        score += 20;
                    } else if (learnedPatterns.colorPreference === 'high' && colorCount >= 7) {
                        score += 20;
                    } else if (learnedPatterns.colorPreference === 'medium' && colorCount >= 4 && colorCount <= 8) {
                        score += 20;
                    } else {
                        score += 5; // Partial credit
                    }
                } else {
                    // Original color scoring for training mode
                    // Thumbnails are usually vibrant with multiple colors
                    if (colors.length >= 5 && colors.length <= 10) {
                        score += 20; // Perfect color variety
                    } else if (colors.length > 3) {
                        score += 10; // Good variety
                    } else if (colors.length <= 2) {
                        score -= 15; // Too plain
                    }
                }
                
                // Check for vibrant colors (thumbnails are eye-catching)
                const hasVibrantColor = colors.some(c => {
                    const r = c.color?.red || 0;
                    const g = c.color?.green || 0;
                    const b = c.color?.blue || 0;
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    return (max - min) > 100; // High saturation
                });
                if (hasVibrantColor) score += 10;
            }

            // === SAFE SEARCH ===
            if (visionData.safeSearchAnnotation) {
                const safe = visionData.safeSearchAnnotation;
                if (safe.adult !== 'VERY_UNLIKELY' && safe.adult !== 'UNLIKELY') score -= 100;
                if (safe.violence === 'VERY_LIKELY' || safe.violence === 'LIKELY') score -= 100;
                if (safe.racy !== 'VERY_UNLIKELY' && safe.racy !== 'UNLIKELY') score -= 50;
            }

            // === FINAL BONUSES ===
            // Massive bonus if we have game title + good thumbnail indicators
            if (hasGameTitle && score > 40) {
                score += 25;
            }

            return Math.max(0, Math.min(100, score));
        }

        // Display images in grid
        function displayImages(images) {
            const grid = document.getElementById('imagesGrid');
            grid.innerHTML = '';
            
            // Add training mode indicator
            if (isTrainingMode) {
                const trainingBanner = document.createElement('div');
                trainingBanner.style.cssText = 'background: #fff3cd; color: #856404; padding: 15px; margin: 0 0 20px 0; border-radius: 8px; text-align: center; font-weight: 600; border: 2px solid #ffc107; grid-column: 1 / -1;';
                trainingBanner.innerHTML = `ðŸŽ“ TRAINING MODE: ${manualSelectionCount}/${TRAINING_THRESHOLD} images selected. Choose the best image to train the AI!`;
                grid.appendChild(trainingBanner);
            } else {
                const aiBanner = document.createElement('div');
                aiBanner.style.cssText = 'background: #d4edda; color: #155724; padding: 15px; margin: 0 0 20px 0; border-radius: 8px; text-align: center; font-weight: 600; border: 2px solid #28a745; grid-column: 1 / -1;';
                aiBanner.innerHTML = `ðŸ¤– AI MODE: Google Vision is auto-selecting images based on ${manualSelectionCount} training examples`;
                grid.appendChild(aiBanner);
            }

            images.forEach((img, index) => {
                const card = document.createElement('div');
                card.className = 'image-card';
                card.innerHTML = `
                    <img src="${img.link}" alt="Game image ${index + 1}" onerror="this.parentElement.style.display='none'">
                    <div class="info">${isTrainingMode ? 'ðŸŽ¯ ' : ''}Click to download as #${currentIndex + 1}.webp</div>
                `;
                card.onclick = () => {
                    if (isTrainingMode) {
                        recordTrainingSelection(img, index, images);
                    }
                    downloadImage(img.link);
                };
                grid.appendChild(card);
            });
        }

        // Download and convert image to WebP
        async function downloadImage(imageUrl) {
            // Clear skip timer when user makes a selection
            clearSkipTimer();
            
            try {
                showSuccess(isTrainingMode ? 'ðŸ“š Recording your choice and downloading...' : 'Downloading and converting...');

                // Try multiple methods to fetch the image
                let blob;
                try {
                    // First try: Direct fetch
                    const response = await fetch(imageUrl);
                    if (!response.ok) throw new Error('Direct fetch failed');
                    blob = await response.blob();
                } catch (e1) {
                    try {
                        // Second try: CORS proxy
                        const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;
                        const response = await fetch(proxyUrl);
                        if (!response.ok) throw new Error('Proxy fetch failed');
                        blob = await response.blob();
                    } catch (e2) {
                        // Third try: Alternative CORS proxy
                        const proxyUrl2 = `https://api.allorigins.win/raw?url=${encodeURIComponent(imageUrl)}`;
                        const response = await fetch(proxyUrl2);
                        if (!response.ok) throw new Error('All fetch methods failed');
                        blob = await response.blob();
                    }
                }

                // Create an image element to convert to WebP
                const img = new Image();
                const objectUrl = URL.createObjectURL(blob);

                img.onload = () => {
                    // Create canvas for conversion
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    // Convert to WebP
                    canvas.toBlob((webpBlob) => {
                        // Download the file with game index number
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(webpBlob);
                        link.download = `${currentIndex + 1}.webp`;
                        link.click();

                        let successMsg = `âœ“ Downloaded as ${currentIndex + 1}.webp`;
                        if (isTrainingMode) {
                            successMsg += ` - Training: ${manualSelectionCount}/${TRAINING_THRESHOLD}`;
                        }
                        successMsg += ' - Moving to next game...';
                        showSuccess(successMsg);
                        
                        // Update download count
                        imageCounter++;
                        document.getElementById('downloadCount').textContent = imageCounter - 1;
                        
                        // Check if training is complete
                        if (isTrainingMode && manualSelectionCount >= TRAINING_THRESHOLD) {
                            completeTraining();
                        }
                        
                        saveProgress();

                        // Clean up
                        URL.revokeObjectURL(objectUrl);
                        URL.revokeObjectURL(link.href);

                        // Auto-advance to next game after delay
                        // Longer delay in AI mode to prevent duplicate downloads
                        const advanceDelay = isTrainingMode ? 1000 : 2500;
                        setTimeout(() => {
                            currentIndex++;
                            saveProgress();
                            loadCurrentGame();
                        }, advanceDelay);
                    }, 'image/webp', 0.9);
                };

                img.onerror = () => {
                    URL.revokeObjectURL(objectUrl);
                    showError('Failed to load image. Try another image or check if the URL is accessible.');
                };

                img.src = objectUrl;
            } catch (error) {
                showError('Download failed: ' + error.message + ' - Try another image or modify the search query.');
            }
        }

        // Analyze image with Google Cloud Vision API
        async function analyzeImage(imageUrl) {
            try {
                const visionUrl = `https://vision.googleapis.com/v1/images:annotate?key=${visionApiKey}`;
                const requestBody = {
                    requests: [{
                        image: { source: { imageUri: imageUrl } },
                        features: [
                            { type: 'LABEL_DETECTION', maxResults: 10 },
                            { type: 'TEXT_DETECTION', maxResults: 5 },
                            { type: 'SAFE_SEARCH_DETECTION' },
                            { type: 'IMAGE_PROPERTIES' }
                        ]
                    }]
                };

                const response = await fetch(visionUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) return null;
                const data = await response.json();
                return data.responses[0];
            } catch (error) {
                console.error('Vision API error:', error);
                return null;
            }
        }
        
        // === TRAINING FUNCTIONS ===
        
        // Record user's manual selection for training
        async function recordTrainingSelection(selectedImage, selectedIndex, allImages) {
            if (!isTrainingMode) return;
            
            manualSelectionCount++;
            showSuccess(`ðŸŽ“ Recording selection ${manualSelectionCount}/${TRAINING_THRESHOLD}...`);
            
            // Analyze the selected image with Vision API
            const visionData = await analyzeImage(selectedImage.link);
            
            if (visionData) {
                const gameTitle = games[currentIndex].title;
                
                // Store training data
                trainingData.push({
                    gameTitle: gameTitle,
                    searchQuery: currentSearchQuery,
                    selectedIndex: selectedIndex,
                    totalImages: allImages.length,
                    imageUrl: selectedImage.link,
                    visionData: visionData,
                    timestamp: Date.now()
                });
                
                console.log(`Training data recorded: ${manualSelectionCount}/${TRAINING_THRESHOLD}`, {
                    game: gameTitle,
                    labels: visionData.labelAnnotations?.map(l => l.description) || [],
                    hasText: !!visionData.textAnnotations?.length
                });
            }
            
            saveProgress();
        }
        
        // Complete training and generate learned patterns
        function completeTraining() {
            showSuccess('ðŸŽ‰ Training Complete! Analyzing your preferences...');
            
            // Analyze training data to learn patterns
            learnedPatterns = analyzeTrainingData(trainingData);
            
            // Switch to auto mode
            isTrainingMode = false;
            autoMode = true;
            
            saveProgress();
            
            alert(`âœ… Training Complete!\n\nThe AI has learned from your ${TRAINING_THRESHOLD} selections and will now automatically choose images based on your preferences.\n\nKey patterns learned:\n- Preferred labels: ${learnedPatterns.topLabels.slice(0, 5).join(', ')}\n- Text preference: ${learnedPatterns.textPreference}%\n- Color variety: ${learnedPatterns.colorPreference}`);
        }
        
        // Analyze training data to extract patterns
        function analyzeTrainingData(data) {
            const patterns = {
                topLabels: [],
                labelWeights: {},
                textPreference: 0,
                colorPreference: 'medium',
                textPatterns: [],
                commonTextElements: []
            };
            
            // Count label frequencies in selected images
            const labelCounts = {};
            let textCount = 0;
            const colorVarietyCounts = [];
            
            data.forEach(entry => {
                const vision = entry.visionData;
                
                // Analyze labels
                if (vision.labelAnnotations) {
                    vision.labelAnnotations.forEach(label => {
                        const desc = label.description.toLowerCase();
                        labelCounts[desc] = (labelCounts[desc] || 0) + label.score;
                    });
                }
                
                // Analyze text presence
                if (vision.textAnnotations && vision.textAnnotations.length > 0) {
                    textCount++;
                    const textWords = vision.textAnnotations[0].description.toLowerCase().split(/\s+/);
                    patterns.textPatterns.push(...textWords);
                }
                
                // Analyze colors
                if (vision.imagePropertiesAnnotation?.dominantColors?.colors) {
                    colorVarietyCounts.push(vision.imagePropertiesAnnotation.dominantColors.colors.length);
                }
            });
            
            // Sort labels by frequency and score
            patterns.topLabels = Object.entries(labelCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(([label, score]) => label);
            
            // Calculate label weights (normalized scores)
            patterns.topLabels.forEach(label => {
                patterns.labelWeights[label] = labelCounts[label] / data.length;
            });
            
            // Calculate text preference (percentage of selections with text)
            patterns.textPreference = Math.round((textCount / data.length) * 100);
            
            // Calculate color preference
            const avgColorVariety = colorVarietyCounts.reduce((a, b) => a + b, 0) / colorVarietyCounts.length;
            if (avgColorVariety < 4) patterns.colorPreference = 'low';
            else if (avgColorVariety > 7) patterns.colorPreference = 'high';
            else patterns.colorPreference = 'medium';
            
            // Find common text elements
            const textWordCounts = {};
            patterns.textPatterns.forEach(word => {
                if (word.length > 2) {
                    textWordCounts[word] = (textWordCounts[word] || 0) + 1;
                }
            });
            patterns.commonTextElements = Object.entries(textWordCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([word]) => word);
            
            console.log('Learned patterns:', patterns);
            return patterns;
        }

        // Auto-select and download best image using Vision API
        async function autoSelectBestImage(images) {
            try {
                const gameTitle = games[currentIndex].title;
                showSuccess(`ðŸ¤– Analyzing ${images.length} images for: ${gameTitle}... (Attempt ${retryAttempt + 1}/${MAX_RETRY_ATTEMPTS + 1})`);

                // Analyze all images in parallel
                const analysisPromises = images.map(async (img, index) => {
                    const visionData = await analyzeImage(img.link);
                    const score = scoreImage(visionData, gameTitle);
                    return { img, score, index };
                });

                const results = await Promise.all(analysisPromises);
                
                // Sort by score and get best image
                results.sort((a, b) => b.score - a.score);
                const bestImage = results[0];

                // Check if score is acceptable
                if (bestImage.score < MIN_ACCEPTABLE_SCORE && retryAttempt < MAX_RETRY_ATTEMPTS) {
                    retryAttempt++;
                    showSuccess(`âš ï¸ Best score (${bestImage.score}/100) is low. Trying different search (Attempt ${retryAttempt + 1}/${MAX_RETRY_ATTEMPTS + 1})...`);
                    
                    // Try alternative search queries focused on thumbnails/logos
                    const gameTitle = games[currentIndex].title;
                    const alternativeSearches = [
                        `${gameTitle} unblocked`,
                        `${gameTitle} html game`,
                        `${gameTitle} unblocked html game`
                    ];
                    
                    currentSearchQuery = alternativeSearches[retryAttempt - 1];
                    document.getElementById('searchQuery').textContent = currentSearchQuery;
                    document.getElementById('searchInput').value = currentSearchQuery;
                    
                    // Increase image count for better selection
                    const newImageCount = 10 + (retryAttempt * 5); // 15, 20, etc.
                    await loadImages(newImageCount);
                    return; // Don't download yet, wait for new results
                }

                showSuccess(`âœ¨ Best match found (score: ${bestImage.score}/100) - Downloading...`);
                
                // Highlight the selected image in the grid
                const cards = document.querySelectorAll('.image-card');
                if (cards[bestImage.index]) {
                    cards[bestImage.index].style.border = '3px solid #4CAF50';
                    cards[bestImage.index].querySelector('.info').innerHTML = 
                        `âœ… AI Selected (${bestImage.score}/100) - Downloading as #${currentIndex + 1}.webp`;
                }

                // Clear skip timer since AI found an image
                clearSkipTimer();
                
                // Wait a moment to show selection, then download
                setTimeout(() => {
                    downloadImage(bestImage.img.link);
                }, 1500);

            } catch (error) {
                showError('AI analysis failed: ' + error.message + ' - Click an image manually');
            }
        }

        // Skip to next game
        function skipGame() {
            clearSkipTimer();
            currentIndex++;
            saveProgress();
            loadCurrentGame();
            clearMessages();
        }
        
        // Start auto-skip timer
        function startSkipTimer() {
            skipTimer = setTimeout(() => {
                showSuccess('â±ï¸ 15 seconds elapsed - Auto-skipping to next game...');
                setTimeout(() => {
                    skipGame();
                }, 1000);
            }, AUTO_SKIP_DELAY);
        }
        
        // Clear skip timer
        function clearSkipTimer() {
            if (skipTimer) {
                clearTimeout(skipTimer);
                skipTimer = null;
            }
        }

        // Reset progress
        function resetProgress() {
            if (confirm('Are you sure you want to reset progress? This will start from the beginning.')) {
                currentIndex = 0;
                imageCounter = 1;
                saveProgress();
                loadCurrentGame();
                clearMessages();
            }
        }
        
        // Reset training data
        function resetTraining() {
            if (confirm('Are you sure you want to reset training data? You will need to manually select 100 images again.')) {
                manualSelectionCount = 0;
                trainingData = [];
                learnedPatterns = null;
                isTrainingMode = true;
                autoMode = false;
                
                // Clear storage
                localStorage.removeItem('visionTrainingData');
                localStorage.removeItem('learnedPatterns');
                
                saveProgress();
                updateTrainingUI();
                
                alert('Training data reset. You are now in training mode again.');
                loadCurrentGame();
            }
        }

        // Update progress bar
        function updateProgressBar() {
            const percent = ((currentIndex / games.length) * 100).toFixed(1);
            const bar = document.getElementById('progressBar');
            bar.style.width = percent + '%';
            bar.textContent = percent + '%';
        }

        // Show error message
        function showError(message) {
            const div = document.getElementById('errorMessage');
            div.innerHTML = `<div class="error">${message}</div>`;
            setTimeout(() => div.innerHTML = '', 5000);
        }

        // Show success message
        function showSuccess(message) {
            const div = document.getElementById('successMessage');
            div.innerHTML = `<div class="success-message">${message}</div>`;
            setTimeout(() => div.innerHTML = '', 3000);
        }

        // Clear messages
        function clearMessages() {
            document.getElementById('errorMessage').innerHTML = '';
            document.getElementById('successMessage').innerHTML = '';
        }

        // Update search with custom query
        function updateSearch() {
            currentSearchQuery = document.getElementById('searchInput').value.trim();
            if (!currentSearchQuery) {
                alert('Please enter a search query');
                return;
            }
            document.getElementById('searchQuery').textContent = currentSearchQuery;
            loadImages();
        }

        // Load images with current search query
        async function loadImages(imageCount = 10) {
            const grid = document.getElementById('imagesGrid');
            grid.innerHTML = '<div class="loading">Fetching images</div>';

            const maxRetries = 3;
            let lastError;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(currentSearchQuery)}&searchType=image&num=${imageCount}`;
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error.message);
                    }

                    if (!data.items || data.items.length === 0) {
                        grid.innerHTML = '<div class="error">No images found for this search</div>';
                        return;
                    }

                    cachedImages = data.items; // Cache the images
                    displayImages(data.items);
                    
                    // Auto-select best image if Vision API is enabled AND not in training mode
                    if (autoMode && visionApiKey && !isTrainingMode) {
                        await autoSelectBestImage(data.items);
                    } else if (isTrainingMode) {
                        showSuccess(`ðŸŽ“ Training Mode: Select your preferred image (${manualSelectionCount}/${TRAINING_THRESHOLD})`);
                    }
                    
                    return; // Success, exit retry loop
                } catch (error) {
                    lastError = error;
                    if (attempt < maxRetries) {
                        grid.innerHTML = `<div class="loading">Retry attempt ${attempt}/${maxRetries}</div>`;
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt)); // Exponential backoff
                    }
                }
            }

            // All retries failed
            showError('API Error: ' + lastError.message + ' (after ' + maxRetries + ' attempts)');
            grid.innerHTML = '<div class="error">Failed to fetch images after multiple attempts. Check your API credentials or try again later.</div>';
        }

        // Load saved API credentials on page load
        window.onload = () => {
            const savedApiKey = localStorage.getItem('googleApiKey');
            const savedSearchEngineId = localStorage.getItem('googleSearchEngineId');
            
            if (savedApiKey) document.getElementById('apiKey').value = savedApiKey;
            if (savedSearchEngineId) document.getElementById('searchEngineId').value = savedSearchEngineId;
        };
    </script>
</body>
</html>
